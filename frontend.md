# Frontend Development Prompt for OpenStack Agent UI

This document outlines the requirements and guidelines for building an interactive frontend for the OpenStack Agent API.

## 1. Project Overview

The goal is to create a user-friendly web interface that allows users to interact with an OpenStack environment by sending natural language commands to a backend API. The frontend should also display the status of the API and the OpenStack connection.

## 2. Backend API Endpoints

The backend is a Flask application defined in `routes.py`. The frontend will interact with the following API endpoints:

### 2.1. `/api/command`

*   **Method:** `POST`
*   **Purpose:** Sends a natural language query to the OpenStack agent for execution.
*   **Request Body (JSON):**
    ```json
    {
      "query": "Your natural language command here (e.g., 'list all servers', 'create a new vm with name myvm image ubuntu flavor small')"
    }
    ```
    *   `query` (string, required): The natural language command to be processed by the OpenStack agent.
*   **Success Response (200 OK, JSON):**
    ```json
    {
      "status": "success",
      "output": [
        "Line 1 of output from the command",
        "Line 2 of output..."
      ]
    }
    ```
    *   `status` (string): Indicates the success of the command processing.
    *   `output` (array of strings): The lines of output generated by the command execution. This is captured from `stdout` of the agent's `execute_command` method.
    *   **Alternative Success Response (if output is not parseable as distinct lines or if `json.JSONDecodeError` occurs on backend when trying to structure output):
    ```json
    {
        "status": "success",
        "raw_output": "Full raw string output from the command"
    }
    ```
*   **Error Responses:**
    *   `400 Bad Request (JSON)`: If `query` is missing in the request body.
        ```json
        {
          "error": "Missing query in request body"
        }
        ```
    *   `500 Internal Server Error (JSON)`: If the OpenStack Agent is not initialized or if any other exception occurs during command processing.
        ```json
        {
          "error": "OpenStack Agent is not initialized. Cannot process command."
        }
        ```
        or
        ```json
        {
          "error": "An error occurred: <specific error message>"
        }
        ```

### 2.2. `/api/status`

*   **Method:** `GET`
*   **Purpose:** Retrieves the current status of the API and the OpenStack connection.
*   **Request Body:** None
*   **Success Response (200 OK, JSON):**
    ```json
    {
      "status": "ok",
      "message": "API is running.",
      "openstack_connection": "Connected" // or "Not Connected"
    }
    ```
    *   `status` (string): Overall status of the API.
    *   `message` (string): A descriptive message about the API status.
    *   `openstack_connection` (string): Indicates if the backend agent is connected to OpenStack.
*   **Error Response (503 Service Unavailable, JSON):** If the OpenStack Agent is not available.
    ```json
    {
      "status": "error",
      "message": "OpenStack Agent not available."
    }
    ```

## 3. Frontend Requirements

### 3.1. Core Functionality

1.  **Command Input:**
    *   A text input field (e.g., a text box or text area) where users can type their natural language commands.
    *   A "Submit" or "Send" button to send the command to the `/api/command` endpoint.
2.  **Output Display:**
    *   A designated area to display the results received from the `/api/command` endpoint.
    *   The output should be clearly presented, ideally preserving line breaks from the `output` array or `raw_output` string.
    *   Consider using a pre-formatted text block or a list for readability.
3.  **Status Display:**
    *   An area (e.g., a header, footer, or a dedicated status panel) to display the API and OpenStack connection status fetched from `/api/status`.
    *   This status should ideally update periodically or on demand (e.g., a refresh button).
4.  **Error Handling:**
    *   Display user-friendly error messages if API calls fail.
    *   Clearly indicate when a command could not be processed and show the error message from the API.
    *   **Client-Side Validation:**
        *   Validate the command input field (e.g., not empty) before sending the request. Provide immediate feedback.
    *   **Network Errors:**
        *   Handle `fetch` or `axios` errors (e.g., `TypeError: Failed to fetch`) gracefully. Display a generic "Network error. Please check your connection and try again."
    *   **API Error Responses (4xx/5xx):**
        *   Parse the JSON error response from the API (e.g., `{"error": "message"}`).
        *   Display the specific error message to the user (e.g., "Error: Missing query in request body.").
        *   For 500 errors, provide a more general message like "An unexpected error occurred on the server. Please try again later." while also logging the specific error from the API for debugging.
    *   **Displaying Errors:**
        *   Use non-intrusive notifications (e.g., toast messages) or a dedicated error display area.
        *   Ensure error messages are clear, concise, and user-friendly.
        *   Provide an option to dismiss error messages.

### 3.2. UI/UX Suggestions

*   **Layout:**
    *   A clean and intuitive layout. Consider a two-panel layout: one for input/controls, and one for output/results.
    *   Alternatively, a chat-like interface could be very effective for command-response interactions.
*   **Responsiveness:** The application should be responsive and usable on different screen sizes (desktop, tablet).
*   **Detailed Component Suggestions:**
    *   **Command Input Field:**
        *   Use a `textarea` for multi-line commands, ideally with auto-grow functionality.
        *   Include a placeholder like "e.g., list all servers, create a new vm...".
    *   **Submit Button:**
        *   Clearly labeled "Send Command" or use an icon (e.g., paper plane).
        *   Should be disabled when a command is already in progress to prevent multiple submissions.
    *   **Output Display Area:**
        *   Use a `<pre>` tag or a similar component that preserves whitespace and line breaks for `raw_output`.
        *   For structured `output` (array of strings), render each string as a separate line or list item for clarity.
        *   Implement copy-to-clipboard functionality for the output.
        *   Consider syntax highlighting if the output is frequently code or structured data (e.g., JSON, YAML).
    *   **Status Display Panel:**
        *   Clearly show "API Status: [Running/Error]" and "OpenStack Connection: [Connected/Not Connected/Checking...]".
        *   Use icons (e.g., green check for connected, red cross for error, spinning icon for checking) for quick visual understanding.
        *   Include a manual "Refresh Status" button.
    *   **Loading Indicators:**
        *   Use a global loading spinner/bar for API calls affecting the entire view.
        *   Consider more granular loading states, e.g., a spinner on the "Submit" button or within the output panel.
    *   **Clear Buttons:**
        *   A "Clear Input" button next to the command input field.
        *   A "Clear Output" button for the results area.
*   **Command History (Optional but Highly Recommended):**
    *   Display as a list of previously sent commands (e.g., in a sidebar or a collapsible panel).
    *   Clicking a history item should populate the command input field.
    *   Provide options to re-send or delete history items.
*   **Styling:** Use a modern and clean design. Consider using a CSS framework like Bootstrap, Tailwind CSS, or a component library compatible with your chosen JavaScript framework (e.g., Material-UI for React, Vuetify for Vue).

### 3.3. Technology Stack (Suggestions)

*   **JavaScript Framework:** React, Vue.js, or Svelte are recommended for building a dynamic single-page application (SPA).
*   **HTTP Client:** Use `fetch` API or libraries like `axios` for making API requests.
*   **State Management (if needed):**
    *   **When to use:** If the application grows with features like command history, theming, user preferences, or complex UI interactions that require shared state across multiple components, a dedicated state management solution becomes beneficial.
    *   **React:** Redux Toolkit (recommended for its ease of use and built-in best practices), Zustand (a simpler, lightweight alternative), or React Context API (suitable for simpler, localized state sharing).
    *   **Vue.js:** Pinia (the official, modern, and lightweight state management library for Vue), or Vuex (still widely used, especially in older projects).
    *   **Svelte:** Svelte's built-in stores (writable, readable, derived) are often sufficient for many application sizes due to Svelte's reactive nature.
    *   **Key state to manage might include:**
        *   Current command input string.
        *   Command output/results (including raw or structured data).
        *   API status (e.g., API running, OpenStack connection status).
        *   Loading state for API calls (e.g., `isLoadingCommand`, `isLoadingStatus`).
        *   Error messages (global or component-specific).
        *   Command history list (if implemented).
        *   User preferences (e.g., theme).

### 3.4. Accessibility (A11y) Considerations

*   **Semantic HTML:** Use appropriate HTML5 elements (e.g., `<main>`, `<nav>`, `<button>`, `<label>`, `<input>`) to provide inherent meaning and structure.
*   **Keyboard Navigation:** Ensure all interactive elements (input fields, buttons, links, custom controls) are focusable and operable using the keyboard alone. The tab order should be logical.
*   **ARIA Attributes:** Use ARIA (Accessible Rich Internet Applications) attributes judiciously to enhance accessibility for dynamic content and custom controls where semantic HTML is insufficient (e.g., `aria-live` for status updates and output regions, `aria-label` or `aria-labelledby` for icon buttons or complex inputs, `aria-describedby` for additional instructions or error messages).
*   **Focus Management:** Manage focus programmatically when appropriate, especially after submitting commands, when new content appears (like output or error messages), or when modals/dialogs are displayed.
*   **Color Contrast:** Ensure sufficient color contrast between text and its background, and for UI elements, to meet WCAG AA guidelines. Use tools to check contrast ratios.
*   **Alternative Text:** Provide descriptive alternative text for all informative images and icons (e.g., using `alt` attribute for `<img>` or `aria-label` for icon fonts/SVGs if they convey meaning). Decorative images should have empty `alt=""`.
*   **Screen Reader Compatibility:** Test the interface with screen readers (e.g., NVDA, JAWS, VoiceOver) to ensure a good experience for visually impaired users. Content should be announced logically.
*   **Form Labels and Instructions:** Associate labels with all form controls explicitly using `for` and `id` attributes, or by wrapping the input with the `<label>`. Provide clear instructions and error feedback associated with inputs.
*   **Resizable Text:** Ensure text can be resized up to 200% without loss of content or functionality.
*   **Clear Visual Cues:** Provide clear visual cues for focus, selection, and interactive states.

## 4. Detailed Interaction Flow Examples

These examples illustrate common user interactions and system responses in more detail.

### 4.1. User Sends a Command (Successful Execution with Structured Output)

1.  **User Action:** Types "list all servers" into the command input field (`textarea`).
2.  **UI State:** The "Send Command" button is enabled.
3.  **User Action:** Clicks the "Send Command" button.
4.  **Frontend Response (Immediate):**
    *   The "Send Command" button becomes disabled to prevent multiple submissions.
    *   A loading indicator appears (e.g., a spinner next to the button or a global overlay).
    *   (Optional, if command history is implemented) The command "list all servers" is added to the command history list, possibly with a "pending" status.
    *   The command input field might be cleared or remain as is, based on design choice.
5.  **Frontend Action (API Call):** Sends a POST request to `/api/command` with the JSON body:
    ```json
    { "query": "list all servers" }
    ```
6.  **Backend Processing:** The backend agent processes the command successfully and prepares a structured output.
7.  **Backend Response (200 OK):** Returns JSON:
    ```json
    {
      "status": "success",
      "output": [
        "ID: 1, Name: vm-alpha, Status: ACTIVE, Image: Ubuntu 20.04",
        "ID: 2, Name: vm-beta, Status: BUILD, Image: CentOS 8"
      ]
    }
    ```
8.  **Frontend Response (On Receiving Data):**
    *   Hides the loading indicator.
    *   Re-enables the "Send Command" button.
    *   Clears any previous error messages from the error display area.
    *   Displays the structured `output` in the designated output area, preserving line breaks and readability:
      ```
      ID: 1, Name: vm-alpha, Status: ACTIVE, Image: Ubuntu 20.04
      ID: 2, Name: vm-beta, Status: BUILD, Image: CentOS 8
      ```
    *   (Optional, command history) Updates the status of the command in history to "success".

### 4.2. User Sends a Command (Successful Execution with Raw Output)

1.  **User Action:** Types "show detailed config for server vm-alpha" into the command input.
2.  **User Action:** Clicks "Send Command".
3.  **Frontend/Backend Interaction:** Similar to 4.1, but the backend might return raw, multi-line text.
4.  **Backend Response (200 OK):** Returns JSON:
    ```json
    {
      "status": "success",
      "raw_output": "Configuration for vm-alpha:\n  CPU: 2 cores\n  RAM: 4096 MB\n  Disk: 50 GB\n  IP: 192.168.1.10\n  Details: Further details here..."
    }
    ```
5.  **Frontend Response (On Receiving Data):**
    *   Displays the `raw_output` in a `<pre>` tag or similar, preserving all formatting:
      ```
      Configuration for vm-alpha:
        CPU: 2 cores
        RAM: 4096 MB
        Disk: 50 GB
        IP: 192.168.1.10
        Details: Further details here...
      ```

### 4.3. User Sends a Command (Backend Error - Agent Not Initialized)

1.  **User Action:** Types "create new network public-net" into the command input.
2.  **User Action:** Clicks "Send Command".
3.  **Frontend Action (API Call):** Sends POST request.
4.  **Backend Response (500 Internal Server Error):** The OpenStack Agent is not initialized.
    ```json
    {
      "error": "OpenStack Agent is not initialized. Cannot process command."
    }
    ```
5.  **Frontend Response (On Receiving Error):**
    *   Hides loading indicator, re-enables "Send Command" button.
    *   Displays a user-friendly error message in a dedicated error display area or as a toast notification: "Error: OpenStack Agent is not initialized. Cannot process command."
    *   (Optional, command history) Updates command status to "failed".

### 4.4. User Sends an Invalid Command (Missing Query - API Error)

1.  **User Action:** Clears the input field and clicks "Send Command" (assuming no client-side validation for this example, or it was bypassed).
2.  **Frontend Action (API Call):** Sends POST request to `/api/command` with `{"query": ""}` or missing `query`.
3.  **Backend Response (400 Bad Request):**
    ```json
    {
      "error": "Missing query in request body"
    }
    ```
4.  **Frontend Response (On Receiving Error):**
    *   Displays error: "Error: Missing query in request body."

### 4.5. API Status Update (Periodic Check - Successful Connection)

1.  **Frontend Action (Automatic or Manual):** On page load, periodically (e.g., every 30 seconds), or on manual "Refresh Status" click, sends a GET request to `/api/status`.
2.  **UI State:** (Optional) Shows a subtle loading indicator in the status panel (e.g., "Status: Checking...").
3.  **Backend Response (200 OK):**
    ```json
    {
      "status": "ok",
      "message": "API is running.",
      "openstack_connection": "Connected"
    }
    ```
4.  **Frontend Response (On Receiving Data):**
    *   Updates the status display panel:
        *   "API Status: Running" (with a green indicator/icon)
        *   "OpenStack Connection: Connected" (with a green indicator/icon)
    *   Hides any status loading indicator.

### 4.6. API Status Update (OpenStack Not Connected)

1.  **Frontend Action:** Sends GET request to `/api/status`.
2.  **Backend Response (200 OK):**
    ```json
    {
      "status": "ok",
      "message": "API is running.",
      "openstack_connection": "Not Connected"
    }
    ```
3.  **Frontend Response (On Receiving Data):**
    *   Updates the status display panel:
        *   "API Status: Running" (green indicator)
        *   "OpenStack Connection: Not Connected" (with a yellow or red warning indicator/icon)

### 4.7. User Attempts to Submit an Empty Command (Client-Side Validation)

1.  **User Action:** Focuses on the command input field but does not type anything (or clears existing text).
2.  **User Action:** Clicks "Send Command".
3.  **Frontend Response (Client-Side Logic, No API Call):**
    *   Detects the input field is empty.
    *   Prevents the API call to `/api/command`.
    *   Displays an inline error message near the input field or as a toast: "Command cannot be empty. Please enter a command."
    *   Keeps the "Send Command" button enabled (or briefly shows a disabled state then re-enables if that's the UX pattern for validation errors).
    *   Focus may be returned to the input field.

## 5. Setup and Running the Backend

*   The backend Flask server (from `routes.py`) typically runs on `http://localhost:5000`.
*   Ensure CORS is enabled on the backend (it is, via `flask_cors`) to allow requests from the frontend's origin (which might be different during development, e.g., `http://localhost:3000` for a React app).

## 6. Key Considerations

*   **Asynchronous Operations:** All API calls are asynchronous. Handle promises or async/await correctly.
*   **User Feedback:** Provide clear and timely feedback to the user for all actions and statuses.
*   **Scalability (Frontend):** While the backend handles the core logic, design the frontend components to be reusable and maintainable.

This prompt should provide a solid foundation for developing the frontend. Good luck!